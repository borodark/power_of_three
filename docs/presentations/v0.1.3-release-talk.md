# PowerOfThree v0.1.3
## Start with Everything. Keep What Performs. Pre-aggregate What Matters.

**A Type-Safe Bridge Between Elixir and Business Intelligence**

---

## About Me

- [Your intro here]
- Working with Elixir/Phoenix applications
- Built PowerOfThree to solve analytics at compile-time

---

## The Problem

**You have:**
- Elixir/Phoenix application with Ecto schemas
- Business needs analytics and dashboards
- Data team wants SQL-based BI tools

**Traditional approach:**
```
Application DB â†’ ETL Pipeline â†’ Data Warehouse â†’ BI Tool
```

**Problems:**
- Duplicate schema definitions
- Manual SQL writing
- Schema drift between app and analytics
- No compile-time validation

---

## Enter: Cube.js

**What is Cube.js?**
- Open-source analytics layer (like GraphQL for analytics)
- Sits between your DB and BI tools
- Define metrics once, query anywhere
- Pre-aggregations for performance

**The Cube Semantic Layer:**
```
Define:     cube("orders")
Dimensions: customer_email, status
Measures:   count, total_revenue
Then:       Query via REST, GraphQL, SQL
```

**Problem:** Cube definitions are in YAML/JS, your schemas are in Elixir

---

## PowerOfThree: The Solution

**One definition, two worlds:**

```elixir
defmodule MyApp.Order do
  use Ecto.Schema
  use PowerOfThree

  schema "orders" do
    field :customer_email, :string
    field :total_amount, :float
    field :status, :string
    timestamps()
  end

  cube :orders, sql_table: "orders"  # That's it!
end
```

**What happens:**
1. Compile-time introspection of Ecto schema
2. Auto-generates Cube.js dimensions and measures
3. Outputs YAML config files
4. Shows you exactly what was generated

---

## Live Demo: The Barbell

**Run `mix compile`:**

```
#         ________                                                       ________
#        /        \                                                    /       /|
#       /   Ecto   \                                                  / CUBE  / |
#      /            \||                                            ||/_______/  |
#     |     Macro    ||===<<--->>==<<--->>=======<<--->>==<<--->>==|||  ...  |  |
#      \            /||                                            |||       |  /
#       \  Elixir  /                                                 | CUBE  | /
#        \________/                                                  |_______|/
#
#       PowerOfThree: Connecting Elixir (HEX) â†â†’ Cube.js (CUBE)
```

**The Barbell Logo:**
- Left: HEX plate (Ecto/Elixir)
- Center: Olympic barbell
- Right: CUBE plate (Cube.js)

---

## What Gets Auto-Generated

**From this schema:**
```elixir
schema "orders" do
  field :customer_email, :string
  field :total_amount, :float
  field :status, :string
  field :item_count, :integer
  timestamps()
end
```

**You get:**
- **Dimensions:** customer_email, status, inserted_at, updated_at
- **Measures:**
  - count (always)
  - total_amount_sum
  - item_count_sum, item_count_distinct

**No manual YAML writing!**

---

## v0.1.3: Client-Side Granularity

**The Old Way (v0.1.2):**
```elixir
# Generated 16 dimensions per timestamp!
inserted_at_second
inserted_at_minute
inserted_at_hour
inserted_at_day
inserted_at_week
inserted_at_month
inserted_at_quarter
inserted_at_year
# ... 8 more for updated_at
```

**The New Way (v0.1.3):**
```elixir
# Just 2 simple time dimensions
inserted_at
updated_at
```

**Granularity specified at query time using Cube.js native `date_trunc`**

---

## Why Client-Side Granularity?

**Benefits:**
1. **Cleaner schemas:** 2 dimensions instead of 16
2. **Smaller YAML files:** 40% reduction in size
3. **Cube.js best practices:** Native support for all 8 granularities
4. **Flexible queries:** Choose granularity when querying, not defining

**Example Query:**
```json
{
  "dimensions": ["orders.inserted_at"],
  "timeDimensions": [{
    "dimension": "orders.inserted_at",
    "granularity": "month"  // or "day", "quarter", etc.
  }]
}
```

---

## Compile-Time Type Safety

**PowerOfThree validates at compile-time:**

```elixir
cube :orders, sql_table: "orders" do
  dimension(:customer_email)  # âœ“ Field exists
  dimension(:customr_email)   # âœ— Compile error!

  measure(:total_amount, type: :sum)  # âœ“ Numeric field
  measure(:status, type: :sum)        # âœ— Can't sum strings!
end
```

**Catches errors before runtime:**
- Typos in field names
- Invalid SQL expressions
- Type mismatches
- Missing fields

---

## The Workflow: Scaffold â†’ Refine â†’ Own

**1. Scaffold (Auto-generate):**
```elixir
cube :orders, sql_table: "orders"
```

**2. See the output:**
```elixir
cube :orders, sql_table: "orders" do
  dimension(:customer_email)
  dimension(:status)
  measure(:count)
  measure(:total_amount, type: :sum, name: :total_amount_sum)
  # ... full generated code shown at compile-time
end
```

**3. Refine (Copy-paste, customize):**
```elixir
cube :orders, sql_table: "orders" do
  dimension(:customer_email)
  dimension(:status)

  measure(:count, name: :total_orders)
  measure(:total_amount, type: :sum, name: :revenue)

  # Add business logic
  measure(:customer_email,
    type: :count_distinct,
    name: :unique_customers
  )
end
```

**4. Own it!** Your definitions, your business logic

---

## Real-World Example: E-Commerce Analytics

**Schema:**
```elixir
defmodule Shop.Order do
  schema "orders" do
    field :email, :string
    field :total_amount, :integer
    field :tax_amount, :integer
    field :status, :string
    belongs_to :customer, Customer
    timestamps()
  end

  cube :orders, sql_table: "orders"
end
```

**Generated automatically:**
- 6 dimensions (email, status, customer_id, inserted_at, updated_at)
- 7 measures (count, total_amount_sum, tax_amount_sum, etc.)

**Then customize with business metrics!**

---

## Architecture Deep-Dive

**Compile-Time Magic:**

```
mix compile
    â†“
PowerOfThree.__using__/1
    â†“
Extract Ecto schema metadata
    â†“
Infer dimensions (string, boolean, time)
Infer measures (count, sum, count_distinct)
    â†“
Generate cube DSL code
    â†“
Validate against schema
    â†“
Output YAML to model/cubes/
    â†“
Show syntax-highlighted preview
```

**All at compile-time!** No runtime overhead.

---

## Code Injection Protection

**PowerOfThree validates SQL expressions:**

```elixir
# Safe - uses field names
dimension(:email_domain, sql: "substring(email FROM '@(.*)$')")

# Detected and logged
dimension(:bad, sql: "email; DROP TABLE users;")
```

**Validation checks:**
- SQL injection patterns
- Dangerous keywords (DROP, DELETE, etc.)
- Invalid field references
- Type mismatches

---

## Integration: Explorer DataFrames

**Query Cube.js, get DataFrames:**

```elixir
# Define your query
query = %{
  measures: ["orders.revenue"],
  dimensions: ["orders.status"],
  timeDimensions: [%{
    dimension: "orders.inserted_at",
    granularity: "month"
  }]
}

# Get results as DataFrame
{:ok, df} = PowerOfThree.query(Order, query)

# Explore in iex
df
|> Explorer.DataFrame.filter(status == "completed")
|> Explorer.DataFrame.arrange(desc: revenue)
```

**Best of both worlds:** Cube.js aggregation + Elixir data science

---

## Deployment Architecture

**Development:**
```
Elixir App â†’ mix compile â†’ YAML files â†’ Local Cube.js (Docker)
```

**Production:**
```
Elixir App
    â†“
    â†“ (generates YAML)
    â†“
Cube.js Cluster (Kubernetes)
    â”œâ”€â”€ API Pods (query layer)
    â”œâ”€â”€ Refresh Workers (pre-aggregations)
    â””â”€â”€ Cubestore (columnar storage)
```

**PowerOfThree handles the "schema definition" part**

---

## What's in model/cubes/?

**Generated YAML (v0.1.3 format):**

```yaml
cubes:
  - name: orders
    sql_table: "orders"

    dimensions:
      - name: customer_email
        type: string
        sql: customer_email
        meta:
          ecto_field: customer_email
          ecto_field_type: string

      - name: inserted_at
        type: time
        sql: inserted_at

    measures:
      - name: count
        type: count
```

**Metadata preserved for debugging!**

---

## Test Coverage: 290 Tests

**What we test:**

1. **Auto-generation logic:**
   - All Ecto types (string, integer, float, datetime, etc.)
   - System field skipping (id)
   - Timestamp handling

2. **Type safety:**
   - Invalid field references
   - Type mismatches
   - SQL injection

3. **YAML output:**
   - Correct format
   - Metadata preservation
   - File naming

4. **Integration:**
   - Live Cube.js queries
   - DataFrame conversion
   - HTTP client

**90% test coverage threshold enforced**

---

## Performance: Pre-aggregations

**Cube.js pre-aggregations = Materialized views**

```elixir
cube :orders do
  # Define pre-aggregation
  pre_aggregation :orders_by_day,
    measures: [:count, :revenue],
    dimensions: [:status],
    time_dimension: :inserted_at,
    granularity: :day,
    refresh_key: %{
      every: "1 hour"
    }
end
```

**Query time:** 5 seconds â†’ 50ms

**PowerOfThree lets you define these in Elixir!**

---

## Comparison: Before and After

**Before PowerOfThree:**
```yaml
# manual YAML file
cubes:
  - name: orders
    sql_table: orders
    dimensions:
      - name: customer_email
        type: string
        sql: customer_email
      - name: status
        type: string
        sql: status
    measures:
      - name: count
        type: count
```

**After PowerOfThree:**
```elixir
cube :orders, sql_table: "orders"  # Done!
```

**40+ lines of YAML â†’ 1 line of Elixir**

---

## The Philosophy

> **Start with everything.**

Auto-generate all dimensions and measures. Get immediate value.

> **Keep what performs.**

Monitor query patterns. Remove unused dimensions.

> **Pre-aggregate what matters.**

Hot paths â†’ pre-aggregations. Cold paths â†’ on-demand.

**PowerOfThree enables this workflow!**

---

## Roadmap: What's Next

**Planned features:**

- [ ] `@schema_prefix` support for multi-tenant schemas
- [ ] Joins support (belongs_to, has_many)
- [ ] Pre-aggregation DSL improvements
- [ ] CI integration helpers
- [ ] Cube.js config validation
- [ ] Dimension `case` statements
- [ ] GraphQL query builder

**Community contributions welcome!**

---

## Why Elixir + Cube.js?

**Elixir strengths:**
- Compile-time metaprogramming
- Type safety via Ecto schemas
- Actor model for real-time updates
- Phoenix LiveView dashboards

**Cube.js strengths:**
- Battle-tested BI layer
- Pre-aggregations
- Multi-database support
- BI tool integrations (Tableau, Metabase, etc.)

**PowerOfThree = Best of both worlds**

---

## Live Demo: Full Workflow

**1. Define schema:**
```elixir
defmodule Demo.Sale do
  use Ecto.Schema
  use PowerOfThree

  schema "sales" do
    field :amount, :decimal
    field :region, :string
    timestamps()
  end

  cube :sales, sql_table: "sales"
end
```

**2. Compile and see output**

**3. Query from iex**

**4. Show in BI tool (if time permits)**

---

## Edge Cases Handled

**Multiple schemas, one table:**
```elixir
# Use different cube names
cube :recent_orders, sql_table: "orders"
cube :archived_orders, sql_table: "orders_archive"
```

**Custom SQL:**
```elixir
dimension :email_domain,
  sql: "substring(email FROM '@(.*)$')"
```

**Filters:**
```elixir
measure :premium_customers,
  type: :count_distinct,
  filters: [%{sql: "total_spent > 1000"}]
```

---

## Production Use Cases

**Where PowerOfThree shines:**

1. **E-commerce:** Orders, customers, products analytics
2. **SaaS:** User behavior, feature usage, retention
3. **FinTech:** Transaction analysis, fraud detection
4. **Healthcare:** Patient outcomes, resource utilization
5. **Logistics:** Delivery metrics, route optimization

**Any domain with:**
- Ecto schemas
- Analytics needs
- BI tool integration

---

## Getting Started

**Installation:**
```elixir
# mix.exs
def deps do
  [
    {:power_of_3, "~> 0.1.3"}
  ]
end
```

**Basic setup:**
```elixir
# In your schema module
use PowerOfThree

# Add cube definition
cube :my_cube, sql_table: "my_table"
```

**Compile and see the magic!**
```bash
mix compile
```

---

## Resources

**Documentation:**
- Hex: https://hexdocs.pm/power_of_3
- GitHub: https://github.com/borodark/power_of_three
- Examples: https://github.com/borodark/power-of-three-examples

**Guides:**
- Ten Minutes to PowerOfThree
- Auto-Generation Blog Post
- Analytics Workflow Guide

**Cube.js:**
- https://cube.dev/docs

---

## Community and Contributing

**We welcome:**
- Bug reports and feature requests
- Documentation improvements
- Code contributions
- Use case sharing

**GitHub Issues:**
https://github.com/borodark/power_of_three/issues

**License:** Apache 2.0

---

## Key Takeaways

1. **One definition, two worlds:** Ecto schemas â†’ Cube.js configs
2. **Compile-time safety:** Catch errors before production
3. **Auto-generation:** Start productive immediately
4. **Client-side granularity:** Clean, flexible time dimensions
5. **Workflow:** Scaffold â†’ Refine â†’ Own
6. **290 tests:** Production-ready reliability

**PowerOfThree bridges the gap between your Elixir app and analytics!**

---

## Questions?

**Thank you!**

**Try PowerOfThree today:**
```bash
mix hex.info power_of_3
```

**Follow along:**
- GitHub: borodark/power_of_three
- Hex: power_of_3

---

## Bonus: The ASCII Art Story

**Design iterations:**

1. **Initial concept:** Simple bar representation
2. **HEX plate:** Hexagonal shape for Ecto/Elixir
3. **CUBE plate:** 3D isometric cube for Cube.js
4. **Barbell details:** Knurling pattern, collar clips
5. **Color:** ANSI highlighting with cyan, yellow, magenta

**Why?**
- Makes compile output memorable
- Represents the connection between Elixir and Cube.js
- Shows attention to detail
- Makes developers smile ðŸ˜Š

**Small details matter in DX!**

---

## Advanced: Meta-Programming Deep Dive

**How auto-generation works:**

```elixir
defmacro cube(name, opts, do: block) do
  quote do
    # Get schema metadata
    fields = __schema__(:fields)
    types = for f <- fields, do: {f, __schema__(:type, f)}

    # Infer dimensions
    dimensions = for {field, type} <- types,
                     type in [:string, :boolean, ...],
                 do: dimension(field)

    # Infer measures
    measures = [measure(:count)] ++
      for {field, type} <- types,
          type in [:integer, :float],
      do: measure(field, type: :sum)

    # Compile to YAML
    # Validate SQL
    # Output to file
  end
end
```

**Compile-time computation = Zero runtime cost**

---

## Advanced: Join Support (Coming Soon)

**Current:**
```elixir
belongs_to :customer, Customer
# No automatic join
```

**Planned:**
```elixir
cube :orders do
  join :customer,
    relationship: :belongs_to,
    sql: "#{orders}.customer_id = #{customer}.id"
end
```

**Will auto-generate based on Ecto associations!**

---

## Advanced: Performance Optimization

**YAML file size comparison:**

```
v0.1.2 (server-side granularity):
  mandata_captate.yaml: 5,780 bytes
  16 time dimensions per timestamp

v0.1.3 (client-side granularity):
  mandata_captate.yaml: 3,467 bytes
  2 time dimensions per timestamp

Reduction: 40%
```

**Fewer dimensions = faster Cube.js startup**

---

## Advanced: CI/CD Integration

**Workflow:**

```yaml
# .github/workflows/cube.yml
- name: Generate Cube configs
  run: mix compile

- name: Upload to S3
  run: aws s3 sync model/cubes/ s3://my-cube-configs/

- name: Restart Cube.js
  run: kubectl rollout restart deployment/cube
```

**Infrastructure as Code:**
- Schema definitions in version control
- Cube configs auto-generated
- Deployed atomically

---

## Thank You!

**Questions? Comments? Ideas?**

**Let's build better analytics together!**

ðŸ‹ï¸ PowerOfThree: Successfully lifting analytics workloads since 2024
